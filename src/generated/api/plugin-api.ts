/* tslint:disable */
/* eslint-disable */
/**
 * Docker Engine API
 * The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client\'s commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release, so API calls are versioned to ensure that clients don\'t break. To lock to a specific version of the API, you prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP `400 Bad Request` error message is returned.  If you omit the version-prefix, the current version of the API (v1.41) is used. For example, calling `/info` is the same as calling `/v1.41/info`. Using the API without a version-prefix is deprecated and will be removed in a future release.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer daemons.   # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 
 *
 * The version of the OpenAPI document: 1.41
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ErrorResponse } from '../models';
// @ts-ignore
import type { Plugin } from '../models';
// @ts-ignore
import type { PluginPrivilege } from '../models';
/**
 * PluginApi - axios parameter creator
 */
export const PluginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get plugin privileges
         * @param {string} remote The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPrivileges: async (remote: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'remote' is not null or undefined
            assertParamExists('getPluginPrivileges', 'remote', remote)
            const localVarPath = `/plugins/privileges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (remote !== undefined) {
                localVarQueryParameter['remote'] = remote;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {File} [tarContext] Path to tar containing plugin rootfs and manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginCreate: async (name: string, tarContext?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginCreate', 'name', name)
            const localVarPath = `/plugins/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/x-tar';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tarContext, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {boolean} [force] Disable the plugin before removing. This may result in issues if the plugin is in use by a container. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginDelete: async (name: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginDelete', 'name', name)
            const localVarPath = `/plugins/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {boolean} [force] Force disable a plugin even if still in use. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginDisable: async (name: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginDisable', 'name', name)
            const localVarPath = `/plugins/{name}/disable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {number} [timeout] Set the HTTP client timeout (in seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEnable: async (name: string, timeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginEnable', 'name', name)
            const localVarPath = `/plugins/{name}/enable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inspect a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginInspect: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginInspect', 'name', name)
            const localVarPath = `/plugins/{name}/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about installed plugins.
         * @summary List plugins
         * @param {string} [filters] A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the plugin list.  Available filters:  - &#x60;capability&#x3D;&lt;capability name&gt;&#x60; - &#x60;enable&#x3D;&lt;true&gt;|&lt;false&gt;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginList: async (filters?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plugins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable). 
         * @summary Install a plugin
         * @param {string} remote Remote reference for plugin to install.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [name] Local name for the pulled plugin.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
         * @param {Array<PluginPrivilege>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginPull: async (remote: string, name?: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'remote' is not null or undefined
            assertParamExists('pluginPull', 'remote', remote)
            const localVarPath = `/plugins/pull`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (remote !== undefined) {
                localVarQueryParameter['remote'] = remote;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (xRegistryAuth != null) {
                localVarHeaderParameter['X-Registry-Auth'] = String(xRegistryAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Push a plugin to the registry. 
         * @summary Push a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginPush: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginPush', 'name', name)
            const localVarPath = `/plugins/{name}/push`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Configure a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginSet: async (name: string, body?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginSet', 'name', name)
            const localVarPath = `/plugins/{name}/set`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upgrade a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {string} remote Remote reference to upgrade to.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
         * @param {Array<PluginPrivilege>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginUpgrade: async (name: string, remote: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pluginUpgrade', 'name', name)
            // verify required parameter 'remote' is not null or undefined
            assertParamExists('pluginUpgrade', 'remote', remote)
            const localVarPath = `/plugins/{name}/upgrade`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (remote !== undefined) {
                localVarQueryParameter['remote'] = remote;
            }

            if (xRegistryAuth != null) {
                localVarHeaderParameter['X-Registry-Auth'] = String(xRegistryAuth);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginApi - functional programming interface
 */
export const PluginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluginApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get plugin privileges
         * @param {string} remote The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginPrivileges(remote: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PluginPrivilege>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPluginPrivileges(remote, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.getPluginPrivileges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {File} [tarContext] Path to tar containing plugin rootfs and manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginCreate(name: string, tarContext?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginCreate(name, tarContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {boolean} [force] Disable the plugin before removing. This may result in issues if the plugin is in use by a container. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginDelete(name: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginDelete(name, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disable a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {boolean} [force] Force disable a plugin even if still in use. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginDisable(name: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginDisable(name, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginDisable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Enable a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {number} [timeout] Set the HTTP client timeout (in seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginEnable(name: string, timeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginEnable(name, timeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginEnable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Inspect a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginInspect(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginInspect(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginInspect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about installed plugins.
         * @summary List plugins
         * @param {string} [filters] A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the plugin list.  Available filters:  - &#x60;capability&#x3D;&lt;capability name&gt;&#x60; - &#x60;enable&#x3D;&lt;true&gt;|&lt;false&gt;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginList(filters?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plugin>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginList(filters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable). 
         * @summary Install a plugin
         * @param {string} remote Remote reference for plugin to install.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [name] Local name for the pulled plugin.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
         * @param {Array<PluginPrivilege>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginPull(remote: string, name?: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginPull(remote, name, xRegistryAuth, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginPull']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Push a plugin to the registry. 
         * @summary Push a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginPush(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginPush(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginPush']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Configure a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginSet(name: string, body?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginSet(name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upgrade a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {string} remote Remote reference to upgrade to.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
         * @param {Array<PluginPrivilege>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginUpgrade(name: string, remote: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginUpgrade(name, remote, xRegistryAuth, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginApi.pluginUpgrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PluginApi - factory interface
 */
export const PluginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluginApiFp(configuration)
    return {
        /**
         * 
         * @summary Get plugin privileges
         * @param {string} remote The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPrivileges(remote: string, options?: any): AxiosPromise<Array<PluginPrivilege>> {
            return localVarFp.getPluginPrivileges(remote, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {File} [tarContext] Path to tar containing plugin rootfs and manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginCreate(name: string, tarContext?: File, options?: any): AxiosPromise<void> {
            return localVarFp.pluginCreate(name, tarContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {boolean} [force] Disable the plugin before removing. This may result in issues if the plugin is in use by a container. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginDelete(name: string, force?: boolean, options?: any): AxiosPromise<Plugin> {
            return localVarFp.pluginDelete(name, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {boolean} [force] Force disable a plugin even if still in use. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginDisable(name: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.pluginDisable(name, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {number} [timeout] Set the HTTP client timeout (in seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEnable(name: string, timeout?: number, options?: any): AxiosPromise<void> {
            return localVarFp.pluginEnable(name, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inspect a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginInspect(name: string, options?: any): AxiosPromise<Plugin> {
            return localVarFp.pluginInspect(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about installed plugins.
         * @summary List plugins
         * @param {string} [filters] A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the plugin list.  Available filters:  - &#x60;capability&#x3D;&lt;capability name&gt;&#x60; - &#x60;enable&#x3D;&lt;true&gt;|&lt;false&gt;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginList(filters?: string, options?: any): AxiosPromise<Array<Plugin>> {
            return localVarFp.pluginList(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable). 
         * @summary Install a plugin
         * @param {string} remote Remote reference for plugin to install.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [name] Local name for the pulled plugin.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
         * @param {Array<PluginPrivilege>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginPull(remote: string, name?: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options?: any): AxiosPromise<void> {
            return localVarFp.pluginPull(remote, name, xRegistryAuth, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Push a plugin to the registry. 
         * @summary Push a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginPush(name: string, options?: any): AxiosPromise<void> {
            return localVarFp.pluginPush(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Configure a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginSet(name: string, body?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.pluginSet(name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upgrade a plugin
         * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
         * @param {string} remote Remote reference to upgrade to.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
         * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
         * @param {Array<PluginPrivilege>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginUpgrade(name: string, remote: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options?: any): AxiosPromise<void> {
            return localVarFp.pluginUpgrade(name, remote, xRegistryAuth, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginApi - object-oriented interface
 * @class PluginApi
 * @extends {BaseAPI}
 */
export class PluginApi extends BaseAPI {
    /**
     * 
     * @summary Get plugin privileges
     * @param {string} remote The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPluginPrivileges(remote: string, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).getPluginPrivileges(remote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {File} [tarContext] Path to tar containing plugin rootfs and manifest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginCreate(name: string, tarContext?: File, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginCreate(name, tarContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {boolean} [force] Disable the plugin before removing. This may result in issues if the plugin is in use by a container. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginDelete(name: string, force?: boolean, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginDelete(name, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {boolean} [force] Force disable a plugin even if still in use. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginDisable(name: string, force?: boolean, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginDisable(name, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {number} [timeout] Set the HTTP client timeout (in seconds)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginEnable(name: string, timeout?: number, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginEnable(name, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inspect a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginInspect(name: string, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginInspect(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about installed plugins.
     * @summary List plugins
     * @param {string} [filters] A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the plugin list.  Available filters:  - &#x60;capability&#x3D;&lt;capability name&gt;&#x60; - &#x60;enable&#x3D;&lt;true&gt;|&lt;false&gt;&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginList(filters?: string, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginList(filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable). 
     * @summary Install a plugin
     * @param {string} remote Remote reference for plugin to install.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
     * @param {string} [name] Local name for the pulled plugin.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
     * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
     * @param {Array<PluginPrivilege>} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginPull(remote: string, name?: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginPull(remote, name, xRegistryAuth, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Push a plugin to the registry. 
     * @summary Push a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginPush(name: string, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginPush(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Configure a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {Array<string>} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginSet(name: string, body?: Array<string>, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginSet(name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upgrade a plugin
     * @param {string} name The name of the plugin. The &#x60;:latest&#x60; tag is optional, and is the default if omitted. 
     * @param {string} remote Remote reference to upgrade to.  The &#x60;:latest&#x60; tag is optional, and is used as the default if omitted. 
     * @param {string} [xRegistryAuth] A base64url-encoded auth configuration to use when pulling a plugin from a registry.  Refer to the [authentication section](#section/Authentication) for details. 
     * @param {Array<PluginPrivilege>} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pluginUpgrade(name: string, remote: string, xRegistryAuth?: string, body?: Array<PluginPrivilege>, options?: RawAxiosRequestConfig) {
        return PluginApiFp(this.configuration).pluginUpgrade(name, remote, xRegistryAuth, body, options).then((request) => request(this.axios, this.basePath));
    }
}

